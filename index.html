<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebulosa Interactiva IA</title>
    <style>
        :root { --accent: #00ff88; }
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #111 0%, #000 100%); font-family: 'Segoe UI', system-ui, sans-serif; }
        
        /* UI Estilo Apple/Glassmorphism */
        #ui-card {
            position: absolute; top: 25px; left: 25px; z-index: 100;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 30px; border-radius: 28px; color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 280px; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        h2 { margin: 0 0 10px 0; font-size: 1.4rem; font-weight: 600; background: linear-gradient(90deg, #fff, var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .field { margin-bottom: 20px; }
        label { display: block; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; opacity: 0.5; margin-bottom: 8px; }

        select, input[type="color"] {
            background: rgba(255,255,255,0.05); color: white; border: 1px solid rgba(255,255,255,0.1);
            padding: 12px; width: 100%; border-radius: 14px; outline: none; appearance: none; cursor: pointer;
        }

        .hint { font-size: 0.75rem; line-height: 1.6; color: var(--accent); opacity: 0.9; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }

        #video-container { position: fixed; width: 1px; height: 1px; opacity: 0; }
    </style>
</head>
<body>

    <div id="ui-card">
        <h2>Experiencia Espacial</h2>
        
        <div class="field">
            <label>Constelación</label>
            <select id="shapeSelector">
                <option value="cloud">Nube Cósmica</option>
                <option value="heart">Corazón de Pulsar</option>
                <option value="saturn">Anillos de Saturno</option>
                <option value="fireworks">Supernova</option>
            </select>
        </div>

        <div class="field">
            <label>Tonalidad de Energía</label>
            <input type="color" id="colorPicker" value="#00ff88">
        </div>

        <div class="hint">
            <b>Interacción:</b><br>
            • Mueve la palma para rotar el eje.<br>
            • Pellizca (pulgar + índice) para expandir.
        </div>
    </div>

    <div id="video-container"><video id="input_video" playsinline muted></video></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- ESCENA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        camera.position.z = 6;

        // --- TEXTURA DE PARTÍCULA (Círculo suave) ---
        const createTicketTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        };

        // --- GENERADOR DE FORMAS ---
        const count = 8000;
        const geo = new THREE.BufferGeometry();
        
        function getPoints(type) {
            const p = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                let i3 = i*3;
                if(type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    p[i3] = 1.6 * Math.pow(Math.sin(t), 3);
                    p[i3+1] = 1.3 * Math.cos(t) - 0.5 * Math.cos(2*t) - 0.2 * Math.cos(3*t) - 0.1 * Math.cos(4*t);
                } else if(type === 'saturn') {
                    const isRing = Math.random() > 0.4;
                    const r = isRing ? 2.5 + Math.random() * 1.5 : 1.5;
                    const a = Math.random() * Math.PI * 2;
                    p[i3] = Math.cos(a) * r;
                    p[i3+1] = isRing ? (Math.random()-0.5)*0.1 : (Math.random()-0.5)*2.5;
                    p[i3+2] = Math.sin(a) * r;
                } else if(type === 'fireworks') {
                    const r = Math.pow(Math.random(), 2) * 4;
                    const a = Math.random() * 6.28; const b = Math.random() * 3.14;
                    p[i3] = r * Math.sin(b) * Math.cos(a); p[i3+1] = r * Math.sin(b) * Math.sin(a); p[i3+2] = r * Math.cos(b);
                } else {
                    p[i3] = (Math.random()-0.5)*10; p[i3+1] = (Math.random()-0.5)*10; p[i3+2] = (Math.random()-0.5)*5;
                }
            }
            return p;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(getPoints('cloud'), 3));
        const mat = new THREE.PointsMaterial({
            size: 0.08,
            map: createTicketTexture(),
            color: 0x00ff88,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            opacity: 0.6
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // --- IA DE MANOS ---
        const video = document.getElementById('input_video');
        const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
        
        hands.onResults(res => {
            if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                const lm = res.multiHandLandmarks[0];
                // Suavizado de movimiento (Lerp manual)
                points.rotation.y += ((lm[9].x - 0.5) * 5 - points.rotation.y) * 0.1;
                points.rotation.x += ((lm[9].y - 0.5) * 5 - points.rotation.x) * 0.1;
                
                const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                const s = Math.max(0.4, d * 12);
                points.scale.lerp(new THREE.Vector3(s, s, s), 0.1);
            }
        });

        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        cam.start();

        // --- INTERFAZ ---
        document.getElementById('shapeSelector').onchange = (e) => {
            points.geometry.setAttribute('position', new THREE.BufferAttribute(getPoints(e.target.value), 3));
        };
        document.getElementById('colorPicker').oninput = (e) => {
            mat.color.set(e.target.value);
            document.documentElement.style.setProperty('--accent', e.target.value);
        };

        function animate() {
            requestAnimationFrame(animate);
            points.rotation.z += 0.001;
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
